Тестове и документация
22.02.2017

fmi@golang.bg
http://fmi.golang.bg/


* Disclamer

Днес няма да си говорим за acceptance testing, quality assurance или нещо, което се прави от "по-низшия" отдел във фирмата.

Всичко тук е дело на програмиста.


* Митът

Проектът идва с готово, подробно задание.

Прави се дизайн.

С него работата се разбива на малки задачи.

Те се извършват последователно.

За всяка от тях пишете кода и приключвате.

Изискванията не се променят, нито се добавя нова функционалност.


* Митът v2.0

Щом съм написал един код, значи ми остава единствено да го разцъкам - няколко print-а, малко пробване в main функцията и толкова.

Така или иначе няма да се променя.

А ако (не дай си боже) това се случи - аз съм го писал, знам го, няма как да допусна грешка.

Най-много да го поразцъкам още малко.


* Тежката действителност

Заданията *винаги* се променят.

Често се налага един код да се преработва.

Писането на код е сложна задача - допускат се грешки.

Програмистите са хора - допускат грешки.

Промяната на модул в единия край на системата като нищо може да счупи модул в другия край на системата.

Идва по-добра идея за реализация на кода, по ред причини.


* Искаме да автоматизираме нещата

За всичко съмнително ще пишем сценарий, който да "цъка".

Всеки сценарий ще изпълнява кода и ще прави няколко твърдения за резултатите.

Сценариите ще бъдат обединени в групи.

Пускате всички тестове с едно бутонче.

Резултатът е "Всичко мина успешно" или "Твърдения X, Y и Z в сценарии A, B и C се оказаха неверни".

Искаме да тестваме и производителността на нашия код.


* Видове тестове

- *Unit*tests* - проверяват дали дадено парче код/пакет работи правилно в изолация
- *Integration*tests* - проверяват дали няколко модула си общуват правилно
- *Functional*tests* - проверяват дали крайната функционалност е както се очаква
- *Benchmark*tests* - извикват една и съща операция `n` пъти и записват времето, отнело за изпълнение


* За какво ни помагат тестовете

- Откриват грешки по-рано
- Позволяват ни уверено да правим промени в системата
- Улесняват работата в екип и приемствеността на проекта
- Дават сигурност на клиенти, колеги, шефове и на самите нас
- Представляват пример как се работи с кода
- Помагат разделянето на интерфейс от имплементация
- Служат като документация и спецификация
- Посочват ни слабите от към производителност части


* За какво не служат тестовете

- Не доказват, че приложението работи
- Не доказват, че приложението е с достатъчно добра производителност
- Не са Quality Assurance


* testing

Разбрахме се, че тестовете са ни супер важни.

Очевидно в стандартната библиотека на Go, има пакет за това.

За да тестваме `foo.go`, създаваме `foo_test.go` в същата директория, който тества `foo.go`

Ако тестваме пакета `foo` може:

- Тестовите файлове също да са в пакета `foo`
- Така имаме достъп до всичко от пакета. Публично или не
- Тестовите файлове да са в пакет `foo_test`
- Така имаме достъп само до публичните неща от пакета
- Или да ги смесваме

С `go`test`./...` пускаме тестовете на един цял проект :)

* Тестовете в testing

- Дефинират се като функции, които приемат указател към `testing.T`
- Функциите трябва да започват с `Test` и слеващата буква да е главна
- Един тест минава успешно, ако не се изпълни `t.Error[f]?()`, `t.Fail()`, `t.Fatal()`...

.code code/errors_and_testing/testing.go /func Test/,/END TEST/

- За тестове които искаме да пропуснем викаме `t.Skip()`
- Тестовете вървят последователно освен ако не бъде извикано `t.Parallel()`
- Препоръчва се да се извика в началото на функцията
- Сигнализира че тест може да бъде изпълняван парелно с и само с други тестове извикали `t.Parallel()`

* Benchmark тестове

- Дефинират се като функции, които приемат указател към `testing.B`
- Функциите трябва да започват с `Benchmark` и слеващата буква да е главна
- Тя се състои от `for` цикъл, извикващ `b.N` пъти тестваната функция
- `go` е достатъчно умен да реши колко пъти да я извика, за да получи адекватни резултати
- Стъпките са 1, 100, 10,000, 1,000,000 50,000,000.

.link https://github.com/ChristianSiegert/go-testing-example

.code code/errors_and_testing/testing.go /func Bench/,/END BENCH/

* Сечението на testing.B и testing.T

- често се налага да има общ код между тестове и бенчмаркове
- с цел да не се повтаряме има testing.TB
- това е общия интерфейс между testing.B и Testing.T
- включва всичките вариации на Error, Fail, Fatal, Log и Skip

.code code/errors_and_testing/table_test.go /func testingFunc/,/END testingFunc OMIT/


* Таблично базирани тестове

- Често се налага да тестсваме един и същи сценариѝ с различни параметри
.code code/errors_and_testing/table_test.go /func TestFibonacci/,/TABLE TEST OMIT/
- От 1.7 има и подтестове които позволяват това да изглежда малко по добре в терминал

* SubTests

.code code/errors_and_testing/table_test.go /func TestSubFibonacci/,/SUB TEST OMIT/

* SubTests continues

    --- FAIL: TestFibonacci (0.00s)
            table_test.go:68: Expected 1 for Fiboncci(2) but got 21
    --- FAIL: TestSubFibonacci (0.00s)
        --- FAIL: TestSubFibonacci/Fibonacci(2) (0.00s)
            table_test.go:68: Expected 1 for Fiboncci(2) but got 21
        --- FAIL: TestSubFibonacci/Fibonacci(10) (0.00s)
            table_test.go:68: Expected 55 for Fiboncci(10) but got 21
    FAIL

- Важно е да се отбележи че подтестовете са независими един от друг. Дори един да се провали, другите ще се изпълнят
- Тъй като са именувани, то не се налага да идентифицираме в кой случай се е случила грешката

* SubBenchmarks

- В случая на Benchmark-овете това е дори още по полезно
- Понеже Benchmark-овете се измерват от началото на Benchmark функцията до нейното завършване, правенето на таблични Benchmark-ове беше невъзможно, но от 1.7 можем да ползваме под Benchmark-ове

.code code/errors_and_testing/table_test.go /func BenchmarkSubFibonacci/,/SUB BENCHMARK OMIT/


* SubBenchmarks output:

    --- FAIL: BenchmarkSubFibonacci/BFibonacci(2)
            table_test.go:68: Expected 1 for Fiboncci(2) but got 21
    BenchmarkSubFibonacci/BFibonacci(8)-16          1000000000               2.65 ns/op
    --- FAIL: BenchmarkSubFibonacci/BFibonacci(10)
            table_test.go:68: Expected 55 for Fiboncci(10) but got 21
    --- FAIL: BenchmarkSubFibonacci
    FAIL

* All together

- Под тестовете разбира се може да бъдат рънвани паралелно или не
- Може да има под тестове на под тестовете и т.н.
.code code/errors_and_testing/table_test.go /func TestGroupSubFibonacci/,/SUB GROUP OMIT/

* All together output

    --- FAIL: TestGroupSubFibonacci (1.00s)
        --- FAIL: TestGroupSubFibonacci/group1 (0.00s)
            --- FAIL: TestGroupSubFibonacci/group1/NonParallel (0.00s)
                    table_test.go:96: Just cause
            table_test.go:98: Oops
            --- FAIL: TestGroupSubFibonacci/group1/Fibonacci(2) (1.00s)
                    table_test.go:69: Expected 1 for Fiboncci(2) but got 21
            --- FAIL: TestGroupSubFibonacci/group1/Fibonacci(10) (1.00s)
                    table_test.go:69: Expected 55 for Fiboncci(10) but got 21
    FAIL


* Demo?

* Документиране на кода

`go` генерира автоматична документация на нашия код, вземайки под внимание:

- всеки коментар, в началото на файл

.code code/errors_and_testing/testing.go /\/\*/,/package fibonacci/

- всеки коментар, дефиниран над функция, метод, тип

.code code/errors_and_testing/testing.go /Fastest Fibonacci/,/func Fibonacci/

- всеки коментар до име в тип, var, const

.code code/errors_and_testing/testing.go /lookupTable stores/,/var lookupTable/


* Виждане на документацията

На всички локално инсталирани пакети

    godoc -http=:6060

Документация на (почти) всички go пакети качени в BitBucket, GitHub, Launchpad и GitLab:

.link http://godoc.org/    godoc.org

* Example тестове - шантавата част

- Документация и тест в едно вътре в тестов файл
- Функцията започва с `Example`, последвана от името на типа или функцията
	Foo -> ExampleFoo
- За метод `Bar` го слагаме с подчертавка след типа `ExampleFoo_Bar`
- Пишем няколко реда, в които използваме нашия тип
- Можем да завършим с коментар започващ с `Output:` и ще бъде тествано че изхода на кода съвпада с останалата част от коментара
- Влиза в документацията на пакета като пример

.code code/errors_and_testing/testing.go /func Example/,/END EXAMPLE/


* Имитации

* Иматации или Mock-ове

- Често се случва да искаме да тестваме код който си говори с друг код или тотално отделна система
- Примерно paypal
- Искаме да сме сигурно че работим правилно с api-то на Paypal във всичките случаи които имаме
- Но не искаме да плащаме на paypal пари всеки път като си пуснем тестовете
- Също важи и когато не искаме да ни фейлват тестовете за една част от кода само защото ползва друга която в момента е бъгава
- Тогава правим имитации или Mock-ове - код, който подръжава на друг но без да ни изпрезва кредитните карти

* В Go

- Ако искам да можем да mock-нем нещо в тестовете си ще е необходимо да можем да го подменим в тях
- За разлика от някои други по динамични езици в които може да подменим time.Sleep или os.Read с наши имплементации, Go трябва да сме малко по имплицитни
- Обикновенно трябва да се приемат интерфейс(и) които имплементират функционалността която искаме примерно Sleeper

    type Sleeper interface {
       Sleep(time.Duration)
    }

- След което просто се подава нашата mock-ната имплементация

* Библиотеки за имитации

- Някои библиотеки ви дават "по - лесен" начин
- Препоръчваме да се обръщате към тях чак когато наистина ви потрябват

.link https://github.com/stretchr/testify

- Цяла библиотека за писане на тестове
- Но има `mock` пакет

.link https://github.com/vektra/mockery
- Библиотека занимаваща се специално с... mockery

.link https://github.com/golang/mock
- Както забелязвате, в github организацията на golang е
- Подсказва някаква връзка с авторите на езика
- Често от подобни места пакети стигат до стандартната библиотека

* Домашно 2

Качено е тук: [[https://gitlab.com/na--/go-chaos-tasks/tree/master/02]]

Срок: петък

Начин на предаване:

- Правите си account в [[https://gitlab.com]]
- Отваряте хранилището със задачите [[https://gitlab.com/na--/go-chaos-tasks]]
- Fork-вате си цялото хранилище във вашия профил
- Правите новото хранилище *private* и ми давате достъп
- Вашите решения *НЕ* ги push-вате в master, а ги пишете в нов branch
- Когато сте готови, правите merge request от branch-а ви с решението към *вашия* master branch и ми го assign-вате на мен
- Използваме този merge request за комуникация и итерация върху решението
